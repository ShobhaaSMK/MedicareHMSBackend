const db = require('../db');
const { randomUUID } = require('crypto');

const mapRoleRow = (row) => ({
  RoleId: row.RoleId || row.roleid,
  RoleName: row.RoleName || row.rolename,
  RoleDescription: row.RoleDescription || row.roledescription,
  CreatedAt: row.CreatedAt || row.createdat,
  CreatedBy: row.CreatedBy || row.createdby,
});

exports.getAllRoles = async (req, res) => {
  try {
    console.log('getAllRoles');
    const query = 
      'SELECT * FROM "Roles" ORDER BY "CreatedAt" DESC';

    const { rows } = await db.query(query);
    res.status(200).json({
      success: true,
      count: rows.length,
      data: rows.map(mapRoleRow),
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching roles',
      error: error.message,
    });
  }
};

exports.getRoleById = async (req, res) => {
  try {
    const { id } = req.params;
    // Validate that id is a valid UUID
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(id)) {
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid RoleId. Must be a valid UUID.' 
      });
    }
    const { rows } = await db.query(
      'SELECT * FROM "Roles" WHERE "RoleId" = $1::uuid',
      [id]
    );
    if (rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Role not found' });
    }
    res.status(200).json({ success: true, data: mapRoleRow(rows[0]) });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching role',
      error: error.message,
    });
  }
};

exports.createRole = async (req, res) => {
  try {
    const { RoleName, RoleDescription, CreatedBy } = req.body;
    if (!RoleName || !RoleName.trim()) {
      return res.status(400).json({ success: false, message: 'RoleName is required' });
    }

    const trimmedRoleName = RoleName.trim();

    // Check if RoleName already exists (proactive validation)
    const checkQuery = 'SELECT "RoleId", "RoleName" FROM "Roles" WHERE LOWER("RoleName") = LOWER($1)';
    const { rows: existingRoles } = await db.query(checkQuery, [trimmedRoleName]);
    
    if (existingRoles.length > 0) {
      return res.status(400).json({
        success: false,
        message: `Role with name "${trimmedRoleName}" already exists. RoleName must be unique.`,
        error: 'DUPLICATE_ROLE_NAME',
      });
    }

    // Validate CreatedBy if provided - must be a valid integer
    let createdByValue = null;
    if (CreatedBy !== undefined && CreatedBy !== null && CreatedBy !== '') {
      const createdByInt = parseInt(CreatedBy, 10);
      if (isNaN(createdByInt)) {
        return res.status(400).json({ 
          success: false, 
          message: 'CreatedBy must be a valid integer. Leave it empty or null if not needed.' 
        });
      }
      createdByValue = createdByInt;
    }

    // RoleId is auto-generated by PostgreSQL SERIAL, so we don't include it in INSERT
    const insertQuery = `
      INSERT INTO "Roles" ("RoleName", "RoleDescription", "CreatedBy")
      VALUES ($1, $2, $3)
      RETURNING *;
    `;
    
    const { rows } = await db.query(insertQuery, [
      trimmedRoleName,
      RoleDescription ? RoleDescription.trim() : null,
      createdByValue,
    ]);
    
    console.log('Role inserted successfully. Rows returned:', rows.length);
    console.log('Inserted RoleId:', rows[0]?.RoleId);
    
    res.status(201).json({
      success: true,
      message: 'Role created successfully',
      data: mapRoleRow(rows[0]),
    });
  } catch (error) {
    if (error.code === '23505') {
      // Unique constraint violation - RoleName already exists (fallback check)
      if (error.message && error.message.includes('RoleName')) {
        return res.status(400).json({
          success: false,
          message: `Role with name "${RoleName}" already exists. RoleName must be unique.`,
          error: 'DUPLICATE_ROLE_NAME',
        });
      }
      return res.status(400).json({
        success: false,
        message: 'A role with this information already exists. Please try again.',
        error: error.message,
      });
    }
    // Handle invalid integer format error
    if (error.message && (error.message.includes('invalid input syntax for type integer') || error.message.includes('invalid input syntax for type numeric'))) {
      return res.status(400).json({
        success: false,
        message: 'CreatedBy must be a valid integer. Leave it empty or null if not needed.',
        error: error.message,
      });
    }
    res.status(500).json({
      success: false,
      message: 'Error creating role',
      error: error.message,
    });
  }
};

exports.updateRole = async (req, res) => {
  try {
    const { id } = req.params;
    // Validate that id is a valid UUID
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(id)) {
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid RoleId. Must be a valid UUID.' 
      });
    }
    const { RoleName, RoleDescription } = req.body;

    // If RoleName is being updated, check if it already exists for another role
    if (RoleName && RoleName.trim()) {
      const trimmedRoleName = RoleName.trim();
      
      // Check if RoleName already exists for a different role
      const checkQuery = 'SELECT "RoleId", "RoleName" FROM "Roles" WHERE LOWER("RoleName") = LOWER($1) AND "RoleId" != $2::uuid';
      const { rows: existingRoles } = await db.query(checkQuery, [trimmedRoleName, id]);
      
      if (existingRoles.length > 0) {
        return res.status(400).json({
          success: false,
          message: `Role with name "${trimmedRoleName}" already exists. RoleName must be unique.`,
          error: 'DUPLICATE_ROLE_NAME',
        });
      }
    }

    const updateQuery = `
      UPDATE "Roles"
      SET "RoleName" = COALESCE($1, "RoleName"),
          "RoleDescription" = COALESCE($2, "RoleDescription")
      WHERE "RoleId" = $3::uuid
      RETURNING *;
    `;
    const { rows } = await db.query(updateQuery, [
      RoleName ? RoleName.trim() : null,
      RoleDescription ? RoleDescription.trim() : null,
      id,
    ]);
    if (rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Role not found' });
    }
    res.status(200).json({
      success: true,
      message: 'Role updated successfully',
      data: mapRoleRow(rows[0]),
    });
  } catch (error) {
    // Handle unique constraint violation for RoleName (fallback check)
    if (error.code === '23505') {
      if (error.message && error.message.includes('RoleName')) {
        return res.status(400).json({
          success: false,
          message: `Role with name "${RoleName}" already exists. RoleName must be unique.`,
          error: 'DUPLICATE_ROLE_NAME',
        });
      }
      return res.status(400).json({
        success: false,
        message: 'A role with this information already exists.',
        error: error.message,
      });
    }
    res.status(500).json({
      success: false,
      message: 'Error updating role',
      error: error.message,
    });
  }
};

exports.deleteRole = async (req, res) => {
  try {
    const { id } = req.params;
    // Validate that id is a valid UUID
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(id)) {
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid RoleId. Must be a valid UUID.' 
      });
    }
    const { rows } = await db.query(
      'DELETE FROM "Roles" WHERE "RoleId" = $1::uuid RETURNING *;',
      [id]
    );
    if (rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Role not found' });
    }
    res.status(200).json({
      success: true,
      message: 'Role deleted successfully',
      data: mapRoleRow(rows[0]),
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error deleting role',
      error: error.message,
    });
  }
};

