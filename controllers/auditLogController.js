const db = require('../db');

const mapAuditLogRow = (row) => ({
  AuditLogId: row.AuditLogId || row.auditlogid,
  ActionLogName: row.ActionLogName || row.actionlogname,
  ActionBy: row.ActionBy || row.actionby,
  ActionDate: row.ActionDate || row.actiondate,
  // Joined fields
  ActionByName: row.ActionByName || row.actionbyname || null,
});

exports.getAllAuditLogs = async (req, res) => {
  try {
    const { actionBy, startDate, endDate } = req.query;
    let query = `
      SELECT 
        al.*,
        u."UserName" AS "ActionByName"
      FROM "AuditLog" al
      LEFT JOIN "Users" u ON al."ActionBy" = u."UserId"
    `;
    const params = [];
    const conditions = [];

    if (actionBy) {
      const actionByInt = parseInt(actionBy, 10);
      if (!isNaN(actionByInt)) {
        conditions.push(`al."ActionBy" = $${params.length + 1}`);
        params.push(actionByInt);
      }
    }

    if (startDate) {
      // Validate date format (YYYY-MM-DD)
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (dateRegex.test(startDate)) {
        conditions.push(`al."ActionDate" >= $${params.length + 1}::date`);
        params.push(startDate);
      }
    }

    if (endDate) {
      // Validate date format (YYYY-MM-DD)
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (dateRegex.test(endDate)) {
        conditions.push(`al."ActionDate" <= $${params.length + 1}::date + INTERVAL '1 day'`);
        params.push(endDate);
      }
    }

    if (conditions.length > 0) {
      query += ' WHERE ' + conditions.join(' AND ');
    }
    query += ' ORDER BY al."ActionDate" DESC';

    const { rows } = await db.query(query, params);
    res.status(200).json({
      success: true,
      count: rows.length,
      data: rows.map(mapAuditLogRow),
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching audit logs',
      error: error.message,
    });
  }
};

exports.getAuditLogById = async (req, res) => {
  try {
    const { id } = req.params;
    const auditLogId = parseInt(id, 10);
    if (isNaN(auditLogId)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid AuditLogId. Must be an integer.',
      });
    }

    const query = `
      SELECT 
        al.*,
        u."UserName" AS "ActionByName"
      FROM "AuditLog" al
      LEFT JOIN "Users" u ON al."ActionBy" = u."UserId"
      WHERE al."AuditLogId" = $1
    `;

    const { rows } = await db.query(query, [auditLogId]);
    if (rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Audit log not found' });
    }
    res.status(200).json({ success: true, data: mapAuditLogRow(rows[0]) });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching audit log',
      error: error.message,
    });
  }
};

const validateAuditLogPayload = (body, requireAll = true) => {
  const errors = [];

  if (requireAll && !body.ActionLogName) {
    errors.push('ActionLogName is required');
  }
  if (body.ActionLogName !== undefined && body.ActionLogName !== null) {
    if (typeof body.ActionLogName !== 'string' || !body.ActionLogName.trim()) {
      errors.push('ActionLogName must be a non-empty string');
    }
  }

  if (body.ActionBy !== undefined && body.ActionBy !== null && body.ActionBy !== '') {
    const actionByInt = parseInt(body.ActionBy, 10);
    if (isNaN(actionByInt)) {
      errors.push('ActionBy must be a valid integer');
    }
  }

  return errors;
};

exports.createAuditLog = async (req, res) => {
  try {
    const errors = validateAuditLogPayload(req.body, true);
    if (errors.length > 0) {
      return res.status(400).json({ success: false, message: errors.join(', ') });
    }

    const {
      ActionLogName,
      ActionBy,
    } = req.body;

    // Validate ActionBy if provided
    let actionByValue = null;
    if (ActionBy !== undefined && ActionBy !== null && ActionBy !== '') {
      const actionByInt = parseInt(ActionBy, 10);
      if (isNaN(actionByInt)) {
        return res.status(400).json({
          success: false,
          message: 'ActionBy must be a valid integer',
        });
      }
      // Check if user exists
      const userExists = await db.query('SELECT "UserId" FROM "Users" WHERE "UserId" = $1', [actionByInt]);
      if (userExists.rows.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'ActionBy user does not exist',
        });
      }
      actionByValue = actionByInt;
    }

    // AuditLogId is auto-generated by PostgreSQL SERIAL, so we don't include it in INSERT
    // ActionDate is auto-set to CURRENT_TIMESTAMP by default
    const insertQuery = `
      INSERT INTO "AuditLog"
        ("ActionLogName", "ActionBy", "ActionDate")
      VALUES ($1, $2, CURRENT_TIMESTAMP)
      RETURNING *;
    `;

    const { rows } = await db.query(insertQuery, [
      ActionLogName.trim(),
      actionByValue,
    ]);

    // Fetch with joined data
    const selectQuery = `
      SELECT 
        al.*,
        u."UserName" AS "ActionByName"
      FROM "AuditLog" al
      LEFT JOIN "Users" u ON al."ActionBy" = u."UserId"
      WHERE al."AuditLogId" = $1
    `;
    const { rows: fullRows } = await db.query(selectQuery, [rows[0].AuditLogId]);

    res.status(201).json({
      success: true,
      message: 'Audit log created successfully',
      data: mapAuditLogRow(fullRows[0]),
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error creating audit log',
      error: error.message,
    });
  }
};

exports.getAuditLogsByActionBy = async (req, res) => {
  try {
    const { actionBy } = req.params;
    const actionByInt = parseInt(actionBy, 10);
    if (isNaN(actionByInt)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid ActionBy. Must be an integer.',
      });
    }

    // Verify user exists
    const userExists = await db.query('SELECT "UserId" FROM "Users" WHERE "UserId" = $1', [actionByInt]);
    if (userExists.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    const query = `
      SELECT 
        al.*,
        u."UserName" AS "ActionByName"
      FROM "AuditLog" al
      LEFT JOIN "Users" u ON al."ActionBy" = u."UserId"
      WHERE al."ActionBy" = $1
      ORDER BY al."ActionDate" DESC
    `;

    const { rows } = await db.query(query, [actionByInt]);
    res.status(200).json({
      success: true,
      count: rows.length,
      data: rows.map(mapAuditLogRow),
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error fetching audit logs by action by',
      error: error.message,
    });
  }
};

